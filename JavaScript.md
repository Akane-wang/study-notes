# 基本概念

- 语法、数据类型、流控制语句、函数

## 语法

- 区分大小写
  - 一切（变量、函数名、操作符）都区分大小写
- 标识符
  - 指 变量、函数、属性的名字，或函数的参数
  - 关键字、保留字、true、false和null不能用作标识符
  - 组成规则
    - 第一个字符必须是字母、下划线（_）或美元符号（$）
    - 其他字符：字母、下划线、美元符、数字
    - 标识符采用驼峰大小写格式
  
- 注释
  - 单行注释 //
  - 块级注释 /**/

- 严格模式
  - 启用严格模式的方式： 在顶部添加 "use strict"
- 语句
  - 以一个分号结尾，如果分号被省略，则由解析器确定语句的结尾
  - 有分号的好处：
    - 避免很多错误：不完整输入等
    - 开发人员可以通过删除多余的空格来压缩ECMAScript代码
    - 加上分号会在某些情况下增加代码的性能：不用花费时间推测应该在哪里插入分号
  - 代码块：代码块让编码意图更加清晰，且降低修改代码时出错的几率

## 关键字、保留字

- 关键字：特定用途，是语言保留的，不能用作标识符
  - 有哪些：
    - break do instanceof typeof case else new var catch finally return void continue for switch while debugger function this with default if throw delete in try
    - 在写标识符时，无论是声明变量还是函数还是操作符（不知道操作符是什么），最好都是一个单词以上不然就简写单词，因为有可能会和关键字搞混
- 保留字：在这门语言中没有特定用途，但是很有可能在将来会被用作关键字
  - 有哪些：(特意标注的是非严格模式下运行时的保留字)
    - abstract `enum` int short boolean `export` interface static byte `extends` long `super` char final native synchronized `class` float package throws `const` goto private transient debugger implements protected volatile double `import` pulic
    - es6作为关键字的：`enum` `export` `extends` `super` `class` `const` `import`
    - es7作为关键字的：`implements` `package` `public` `interface` `private` `static` `let` `protected` `yield`
    - 其他限制： `eval` `arguments`
- 使用关键字做标识符，会导致`identifier expected`错误，使用保留字做标识符可能也会导致不同的错误，具体取决于特定的引擎

## 变量

- ECMAScript的变量是`松散型`的：即可以用来保存任何类型的数据，每个变量仅仅是一个用于保存值的占位符而已。定义时使用var + 变量名（即一个标识符）
- 一个变量的几个状态：
  - 声明： var message  //此时message没有经过初始化，所以message = undefined
    - 在声明一个变量（标识符）时，最好给这个变量一个初始化的值，这个值虽然可以是undefined，但是最好不是，因为没有初始化也是undefined，没办法判断这个值是否被初始化了
  - 初始化:（在定义变量的同时就可以设置变量的值） var message = "a"
  - 赋值: message = 100 // 变量message 一开始保存了字符string类型，后又被赋值为number类型，这样的行为时有效但不推荐的
  - 用 `var` 操作符在局部作用域定义变量后，该变量将成为定义该变量的作用域中的局部变量，这个作用域外，是无法获取到这个变量的（肯定有办法的啦，就是这样，自己给自己挖坑，又自己埋）。
    - 比如函数：这个变量在函数退出后就被销毁
    - 如果在局部作用域里不用var去声明变量而是直接赋值--> 在局部作用域中的变量就会升级为全局变量，则该作用域外也可以访问它。但是严格模式下回抛出 `renferenceError` 错误

## 数据类型

- 数据类型（具有动态性，虽然感觉6种数据类型不够用，但是也没有定义其他数据类型的必要）
  - 简单数据类型（5）：Undefined、Null、Boolean、Number、String
  - 复杂数据类型（1）：Object（本质是由一组无序的名值对(键值对)组成的）
- typeof操作符（不是函数，所以typeof()可以使用，但是括号并不是必须的）：检测给定变量的数据类型（ECMAScript是松散类型的，松散类型体现在哪里呀？）
  - 'undefined' -- 未定义
  - 'boolean' -- 布尔值
  - 'string' -- 字符串
  - 'number' -- 数值
  - 'object' -- 对象、null(null 会被认为是一个空的对象引用)
  - 'function' -- 函数（是对象，而不是一种数据类型，但函数也有自己的特殊属性，因此，通过typeof操作符来区分函数和其他对象是有必要的。）
  - ** 正则表达式：typeof正则表达式在Safari 5- && Chrome 7- 会返回 function，而其他浏览器会返回object
- Undefined类型
  - 只有一个值undefined，第一个只有一个值的数据类型
  - 在使用var声明变量但未对其加以初始化时变量的值即为undefined
  - 声明变量但不初始化时，该变量 == 字面量undefined： 字面量undefined的主要作用是用于比较，引入这个值的目的是为了区分null（空对象指针）和未经初始化的变量
  - 声明变量和不声明变量
    - 声明变量但没有初始化的情况下，打印出来的值是undefined，没有声明的变量打印出来会报错。
    - 声明变量和未声明变量在调用typeof都会返回undefined（技术角度看有本质区别，实际上无论对哪种变量都不可能执行真正的操作）
    - 显示的初始化变量之所以是明智的选择是因为希望在调用typeof操作符返回undefined时可以分辨出是没有声明该变量而不是没有初始化该变量。
- Null 类型
  - 第二个只有一个值的数据类型，值为null，表示一个空对象指针
  - 在定义变量准备用于保存对象时，在初始化时将该变量初始化为null（推荐）
  - undefined是派生自null，因此：`undefined == null`
- Boolean 类型
  - 有两个字面量值：true、false（区分大小写）
  - ECMAScript中所有类型的值都有与这两个Boolean值等价的值
  - 将值转换成Boolean值：Boolean()
  - 转换规则：转换规则对理解流控制语句（如if）自动执行相应的Boolean转换非常重要
  
    |数据类型|转为true值|转为false值|
    |-------|:--------:|---------:|
    |Boolean|true|false|
    |String|任何非空字符串|""(空字符串)|
    |Number|任何非零数字值(包括无穷大)|0,NaN|
    |Object|任何对象|null|
    |Undefined|n/a|undefined|
      ---
      ps: n/a:也可叫N/A，是not applicable的缩写，意为不适用
- Number 类型
  - 支持各种数据类型
    - 十进制
    - 八进制： 0+(0~7),超出数字范围会被当做十进制解析，0被忽略
    - 十六进制：0x+(0~9,A~F),A~F可大写，可小写
    - 算数运算时，都会被转换成十进制数值
  - 浮点数值
    - 数值中必须包含一个小数点，小数点后必须至少有一位数字，小数点签名可以没整数，但是不推荐这种写法
    - 内存空间（浮点数值）= 2 * 内存空间（整数值）
      - 小数点后没有任何其他数字（1.）、浮点数本身是一个整数（10.0），则会被转换为整数
    - 极大、极小的数值，可以用e表示法表示的浮点数值表示
      - 默认情况下：小数点后面带6个0以上的浮点数转换为科学计数法
    - 浮点数进行计算时精度不如整数，会出现舍入误差，因此，不要测试某个特定的浮点数值
  - 数值范围
    - -Infinity(负无穷) -- 5e-324 -- 1.797693135e+308 -- +Infinity(正无穷)
    - `isFinite()`:
      - 有穷数： isFinite(result) ==> true
      - 无穷数：isFinite(result) ==> false
      - 执行极大、极小数值计算时，检测监控这些值是可能且必要的。
  - NaN
    - 任何数值除以0都会返回NaN，不会影响其他代码执行
      - 实际上，0/0 == NaN,其他：正数/0 == Infinity,负数/0 == -Infinity
    - 特点：
      - 任何涉及NaN的操作都会返回NaN
      - NaN与任何值都不相等，包括NaN本身
      - isNaN()函数接受一个`任何类型`的参数，`isNaN()`接收到以后，尝试转换该值为数值，能转换的就会被转换为数值，否则就返回`true`
        - 基于对象调用isNaN()时，先调用对象的valueOf()确定该方法的返回值是否为数值，不能再基于这个返回值调用toString()方法，再测试返回值
  - 数值转换
    - 把非数值转为数值：
      - 适用于任何类型
        - Number()
        - 转换规则
          - Boolean： true--> 1; false --> 0
          - Number: 对应number
          - Null: null --> 0
          - Undefined: undefined --> NaN
          - String:
            - [±数字] --> 十进制数值（忽略最前面的0）
            - [浮点格式] --> 对应的浮点值（忽略最前面的0）
            - [十六进制] --> 转为相同大小的十进制
            - [''(不包含任何字符)] --> 0
            - [其他] --> NaN
            - [对象] --> object.valueOf()-->NaN --> object.valueOf().toString()
        - 问题：在转换字符串时比较复杂且不够合理
      - 把字符串转为数值
        - parseInt():
          - 忽略字符串前面的空格，直至第一个[非空字符],[非空字符]不是数字字符或负号，则返回NaN;(parseInt解析空字符串返回NaN)
          - 遇到第一个数字字符后，会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符，则返回，后面的非数字字符被忽略。
          - 字符串中第一个字符是数字字符，parseInt也能识别其他整数形式（0+其他数字字符-->8进制解析，0x+0-9/A-F-->16进制解析）
            - ECMAScript 5JavaScript引擎中，不再具有解析八进制的能力，因此无法被当做八进制使用
              - 提供第二个参数，转换时使用的基数（多少进制）： parseInt('0xAF',16);
            - 最好无论何时都明确指定基数，写上第二个参数（基数转换）
        - parseFloat()：
          - 转换方式与parseInt()类似
          - 遇到第二个小数点是无效的，后面的字符串都被忽略(包括那个不正常的小数点)
          - 始终忽略前导零，只解析十进制
            - 可以识别所有浮点数值格式，包括16进制，但是16进制格式的字符串始终会被转换成0，因此[没有第二个参数指定基数的用法]
          - 如果字符串包含的是一个可解析为整数的数(没有小数点 or 小数点后面都是 0 )，parseFloat会返回整数
- String 类型
    - 表示由0或多个[16位Unicode字符]组成的字符序列，即字符串
    - 由 “ " ” 或 “ ' ” 表示
  - 字符字面量
    - 转义序列：用于表示非打印字符或其他用途的字符
      - `\n`:换行
      - `\t`:制表
      - `\b`：空格
      - `\r`：回车
      - `\f`：进纸
      - `\\`：斜杠
      - `\'`：单引号，在用单引号表示的字符串中使用
      - `\"`：双引号，在用双引号表示的字符串中使用
      - `\xnn`：以十六进制代码nn表示的一个字符，其中n为0~F，例如\x41表示“A”
      - `\unnn`：以十六进制代码nnn表示的一个Unicode字符，其中n为0~F，例如\u03a3表示希腊字符∑
  - 字符串的特点
    - 字符串被创建保存到某个变量里就不能被改变，除非这个字符串值被销毁。被销毁后可以用其他新的字符串填充这个保存着原来字符串的变量
- 转换为字符串
    - 方式
      - toString():
        - 数值、布尔值、对象、字符串值（字符串也有toString方法，返回字符串的一个副本）都有toString()方法；
          - 多数情况下，调用toString可以不用传递参数
          - 调用数值的toString()方法时，可以传递一个参数：输出数值的基数（可以指定输出的任意基数，默认以十进制输出）
        - null、undefined没有toString()方法
      - String():
        - 可以将任何类型的值转为字符串
        - 遵循转换规则：
          - 1.转换的值有toString()方法，则调用该方法并返回相应结果
          - 2.如果值是null，则返回 "null"
          - 3.如果值是undefined，返回 "undefined"
          - PS:在调用String时，内部会先调用toString方法（判断有toString()的话，没有才调用String()方法）
          - 使用 + 操作符把要转换的某个值与字符串""相加，该值就会变成字符串
- object 类型
  - 对象：一组数据和功能的集合
    - 创建：new [要创建的对象类型的名称]
      - 创建自定义对象：创建object类型的实例，为其添加属性、方法
    - object每个实例都具有的属性、方法：
      - constructor:保存用于创建当前对象的函数
      - hasOwnProperty("propertyName"): 检查某个属性在当前对象实例(而非实例的原型)中是否存在,propertyName必须以字符串的形式指定
      - isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型；`用于测试一个对象是否存在于另一个对象的原型链上，object：在该对象的原型链上搜寻，返回值：Boolean，表示调用对象是否在另一个对象的原型链上。`
      - propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句来枚举。参数propertyName必须以字符串形式指定。
      - toLocaleString():返回对象的字符串表示，该字符串与执行环境的地区对应
      - toString():返回对象的字符串表示。
      - valueOf():返回对象的字符串、数值、布尔值表示。通常与toString()方法的返回值相同。

## 操作符
- 操作符：用于操作数据值（包括算术操作符[+/-],位操作符，关系操作符、相等操作符）
  - 能够适用于很多值（字符串、数字值、布尔值、对象），在应用于对象时，相应地操作符通常会调用对象的valueOf()或toString()方法以取得可操作的值。
- 一元操作符：只能操作一个值
  - 递增、递减操作符
    - 执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。
    - 有两个版本：前置型、后置型
      - 前置型：前置递增、递减操作的优先级和执行语句的优先级相等，整个语句会从左至右被求值
      - 后置型：递增、递减操作时再包含它们的语句被求值以后才执行的
      ```
        var num1 = 2;
        var num2 = 20;
        var num3 = --num1 + num2; // 21
        var num4 = num1 + num2; //21
      ```
      ```
        var num1 = 2;
        var num2 = 20;
        var num3 = num1-- + num2; // 22:先计算num1+num2;再计算num1--
        var num4 = num1 + num2; // 21
      ```
    - 应用于不同的值时，递增、递减操作符遵循规则（所有类型都将变成数值变量）：
      - 包含有效数字字符的字符串（记为A）：将A转换成数字值，再执行+/- 1 的操作，`A变为数值变量`
      - 不包含有效数字字符的字符串（B）：将变量值设置为NaN
      - 布尔值：false转为0，true转为1，再执行 +/- 1的操作
      - 浮点数：执行 +/- 1 的操作
      - 对象：调用对象的valueOf()方法，以取得一个可供操作的值，然后对该值应用前述规则；若res = NaN,则调用toString()方法后再应用前述规则。 
  - 一元加和减操作符
    - 一元加操作符：
      - 数值前：`+` 不会有任何影响
      - 非数值：`+`像Number()转型函数一样对这个值执行转换
        - Boolean：false、true被转换成0，1
        - 字符串：按照一组特殊的规则进行解析
        - 对象：先调用valueOf()和toString()方法，再转换得到的值
    - 一元减操作符：
      - 数值：将值变为负数
      - 非数值：先将该值以一元+操作符的方式进行转换，再转换为负数
- 位操作符
  - 位操作符：
    - 用于在最基本的层次上，即按内存中表示数值的位来操作数值。
    -  有符号的整数，32位中的前31位用于表示整数的值，第32位用于表示数值的符号（第32位又叫符号位，决定了其他位数值的格式）
       -  0：正数：以二进制格式存储，31位中的每一位都表示2的幂
       -  1：负数：以二进制码存储，但使用的格式是`二进制补码`
          -  计算一个数值的二进制补码的方式：
             -  求这个数值绝对值的二进制码
             -  求二进制反码（0替换为1，,替换为0）
             -  得到的二进制反码加1
    -  对数值应用位操作符时，转换过程会导致严重的副效应：在对特殊的NaN、Infinity值应用位操作时，这两个值都被当成0来处理
    -  对非数值应用为操作符，会先使用Number()函数将该值转换为一个数值，再应用位操作，得到的结果将是一个数值。
 - 按位非(NOT):
   - 操作符表示： ~
   - 执行结果：返回数值的反码
   - 在数值表示的最底层执行操作，速度更快
 - 按位与(AND):
   - 操作符表示： &
   - 执行结果：在两个数值的对应位都是1时才返回1，任何一位是0都返回0
 - 按位或(OR):
   - 操作符表示： |
   - 执行结果：任何一个位是1都返回1，只有在两个位都是0的情况下才返回0
 - 按位异或(XOR):
   - 操作符表示： ^
   - 执行结果：在两个数值对应位上只有一个1时才返回1，对应两位都是1或都是0，则返回0
 - 左移：
   - 操作符表示： <<
   - 执行结果：将数值的所有位向左移动指定的位数，原数值的右侧多出的空位以0来填充
 - 有符号的右移：
   - 操作符表示： >>
   - 执行结果：将数值向右移动，但保留符号位（正负号标记），由于移动空出的原数值的左侧、符号位的右侧的空位则以符号位来表示
 - 无符号右移：
   - 操作符表示：>>>
   - 执行结果：会将数值的所有32位都向右移动
     - 于正数而言：无符号位右移的结果与有符号右移相同
     - 于负数来说：情况不同甚至差异很大
- 布尔操作符
  - 操作符：非(NOT)、与(AND)、或(OR)
  - 逻辑非
    - 操作符：!
    - 返回值：Boolean
    - 操作：将它的操作数转换为一个布尔值，再对其求反
    - 模拟Boolean()转型函数的行为：`!!`
  - 逻辑与(短路操作符)
    - 操作符：&&
    - 操作数类型：任何类型，在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值
      - 遵循规则：
        - 若：
          - 第一个操作数是对象，则返回第二个操作数
          - 第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象
          - 两个操作数都是对象，则返回第二个操作数
          - 有一个操作数是null、NaN、undefined，则返回null、NaN、undefined
  - 逻辑或(短路操作符)
    - 操作符：||
    - 若有一个操作数不是布尔值，逻辑或也不一定返回布尔值
      - 遵循规则：
        - 若：
          - 第一个操作数是对象，则返回第一个操作数
          - 第一个操作数的求值结果为false，则返回第二个操作数
          - 两个操作数都是对象，则返回第一个操作数
          - 两个操作数是null、NaN、undefined，则返回null、NaN、undefined
    - 可利用其这一行为来避免为变量赋null、undefined值
    ```
    var a = b||c;
    // b 为 null、undefined 就 将C赋给 a ,否则就将b赋给 a
    ```
- 乘性操作符
  - 乘性操作符：乘法、除法、求模
    - 在操作数为非数值的情况下会执行自动的类型转换（后台先使用Number()转型函数将非数值转换为数值--[""->0,true-->1]）
    - 乘法：
      - 操作符: *
      - 遵循规则：
        - 操作数是数值：执行常规乘法计算（乘积超过ECMAScript，则以正负无穷表示）
        - 有一个操作数是NaN，则结果是NaN
        - Infinity * 0 == NaN
        - Infinity * !0(非0) == Infinity/-Infinity(取决于有符号操作数的符号)
        - Infinity * Infinity == Infinity
        - 操作数不是数值，则在后台调用Number()将其转换为数值，再应用如上规则
    - 除法：
      - 操作符：/
      - 遵循规则：
        - 操作符都是数值，执行常规的除法计算
        - 一个操作数是NaN，则结果是NaN
        - Infinity/Infinity == NaN
        - 0/0 == NaN
        - 0/非零有限数 == ± Infinity
        - 非零数值/Infinity == ± Infinity
        - 操作数不是数值，则在后台调用Number()将其转换为数值，再应用如上规则
    - 求模
      - 操作符：%
      - 遵循规则：
        - 数值：常规除法计算，返回除得的余数
        - Infinity % 有限大的数值 == NaN
        - 有限大的数值%0 == NaN
        - Infinity % Infinity == NaN
        - 有限大的数值 % Infinity == （被除数）
        - 0 % x == 0
        -  操作数不是数值，则在后台调用Number()将其转换为数值，再应用如上规则
- 加性操作符
  - 加法：
    - 遵循规则：
      - NaN + x == NaN
      - Infinity + Infinity == Infinity
      - -Infinity + (-Infinity) == -Infinity
      - Infinity + (-Infinity) == NaN
      - +0 + +0 == +0
      - -0 + -0 == -0
      - +0 + -0 == +0
      - 有一个操作数是字符串的情况：
        - str + str == strstr
        - str + other(非字符串) == strother(转换为字符串，并将两个字符串拼接起来)
  - 减法：
    - 遵循规则：
      - 两个操作符都是数值，执行常规的算数减法操作并返回结果
      - 一个操作数是NaN，则结果是NaN
      - Infinity - Infinity == NaN
      - -Infinity - (-Infinity) == NaN
      - Infinity - (-Infinity) == Infinity
      - -Infinity - Infinity == -Infinity
      - +0 - (+0) == +0
      - +0 - (-0) == -0
      - -0 - (-0) == +0
      - 有一个操作数是字符串，boolean、null、undefined则先在后台调用Number()函数将其转为数值，然后再根据前面的规则执行减法计算。转换的结果若是NaN，则其结果就是NaN
      - 有一个操作数是对象,则调用对象的valueOf()方法以取得表示该对象的数值,得到的值若是NaN,则减法的结果就是NaN,如果对象没有valueOf()方法,则调用其toString()方法并将得到的字符串转换为数值
- 关系操作符
  - 关系操作符：<、>、<=、>=（return Boolean）
  - 遵循规则：
    - 操作数都是数值，执行数值比较
    - 操作数都是字符串，比较两个字符串对应的字符编码值
    - 一个操作数是数值，将另一个操作数转换为一个数值，然后执行数值比较
    - 一个操作数是对象，调用这个对象的valueOf方法，用得到的结果按照前面的规则执行比较；如果对象没有valueOf方法，则调用toString()方法，并用得到的结果按照前面的规则进行比较
    - 一个操作符是布尔值，将其转换为数值，然后再执行比较
  - 任何操作数与NaN进行比较，结果都是false
- 相等操作符
  - 确定两个变量是否相等在编程中是非常重要的，涉及到对象比较时问题就较为麻烦，有人质疑对象类型转换是不合理的。因此ECMAScript提出解决方案：提供两组操作符
  - 两组操作符：
    - 相等、不相等：先转换再比较
      - 操作符：==，!=
      - 返回值：两个操作数相等，则返回true;对于不相等：两个操作数不相等，则返回true
      - 这两个操作符都会先转换操作数（通常称为强制转型），再比较它们的相等性
      - 遵循规则：两个操作数分别为A,B
        - A是boolean,在比较值钱先将A转换为数值：false=>0,true => 1;
        - A是string，B是number,比较之前将A转换为number;
        - A是object，B!object，则调用object的valueOf()方法，用得到的基本类型值按照前面的规则进行比较
          - 遵循规则：
            - null == undefined
            - 不能转换null、undefined为任何值，在比较相等性之前
            - 一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true
            - 两个操作数都是NaN，相等操作符返回false，不相等操作符返回true。即使两个操作数都是NaN，相等操作符也返回false，因为NaN!=NaN
            - 两个操作数都是对象，则比较它们是不是同一个对象，指向同一个对象，则相等操作符返回true，否则返回false

            表达式|值
            -------|---------
            null == undefined | true
            "NaN" == NaN | false
            5 == NaN | false
            NaN == NaN | false
            NaN != NaN | true
            false == 0 | true
            true == 1 | true
            true == 2 | false
            undefined == 0 | false
            null == 0 | false
            "5" == 5 | true
    - 全等、不全等：仅比较不转换
      - 操作符：===、!==
      - 为了保持代码中数据类型的完整性，推荐使用全等、不全等操作符
- 条件操作符
  - variable = boolean_expression ? true_value : false_value;
- 赋值操作符
  - 操作符表示：= -> 把右侧的值赋给左侧的变量
  - 扩展：实现复合赋值操作 -> 在等于号(=)前面添加乘性操作符、加性操作符或位操作符等
  - 复合赋值操作符(作用：简化赋值操作，不会有任何性能提升)
    - * -> *=
    - / -> /=
    - % -> %=
    - + -> +=
    - - -> -=
    - << -> <<=
    - 有符号右移赋值：>> -> >>=
    - 无符号右移赋值: >>> -> >>>=
- 逗号操作符
  - 作用：逗号操作符可以在一条语句中执行多个操作：var num1 =1,num2=2,num3=3;
  - 使用场景：用于声明多个变量、赋值；赋值时，逗号操作符总会返回表达式中的最后一项（var num = (5,1,4,8,0); // num == 0,这种使用方式并不常见）

## 语句（流控制语句）

- if语句
  - if (condition) {statement1}else {statement2}
    - condition可以是任意表达式，对这个表达式求值的结果不一定是boolean值，ECMAScript会自动调用Boolean()转换函数将这个表达式的结果转换为一个布尔值
- 前测试循环语句
  - while语句（在循环体内的代码被执行前，就会对出口条件求值，可能导致循环体内的代码永远都不被执行）
  - for语句（具有在执行循环前初始化变量和定义循环后要执行的代码的能力:当条件表达式(i < count)为true时进入for循环，若执行了循环体中的代码，则一定会对循环后的表达式(i++)求值）
    - for循环相较于while循环，只是把与循环有关的代码集中在一个位置，while无法做到的for也无法做到
    - 在for循环的变量初始化表达式中，也可以不适用var关键字，该变量的初始化可以在外部执行
    - ECMAScript中不存在块级作用域，因此循环内部定义的变量也可以在外部访问到
      ```
          1.使用闭包模仿块级作用域
          2.一点点经典的考题：for循环中最后打印出来的那个数是最后一个被break的数
          3.由于他的这个特性，所以在ES6中有let,const去替换var解决这个问题，那么let、const，var的区别是什么
          3.1 var：变量提升，说到变量提升，函数提升高于变量提升
          3.2 let，const：暂时性死区
          3.3 const一个对象，那么嗨能不能改呢？理论上来说是不可以改的，但是有办法，就是object.defineProperty,使用writeable属性，改为true就可以更改这个对象的值了
      ```
  ```js
    var count = 10;
    for (var i = 0;i < count; i++) {
      alert(i);
    }
  ```
  与while的这段代码一样
  ```js
  var count = 10;
  var i = 0;
  while (i < count) {
    alert(i);
    i++;
  }
  ```
  - for 语句中的初始化表达式、控制语句、循环后表达式都是可选的，将其全部省略则创建一个无限循环
    ```
    for(;;) {
      doSomething();
    }
    ```
  - 只给出控制表达式就把for循环转换成了while循环。
    ```
    var count = 10;
    var i = 0;
    for(; i < count; ) {
      alert(i);
      i++;
    }
    ```
- 后测试循环语句
  - do-while语句（只有在循环体中的代码执行之后，才会测试出口条件，即在对表达式求值之前，循环体内的代码至少会被执行一次）
- for-in语句
  - 是什么：一种精准的迭代语句
  - 做什么：用于枚举对象的属性
  - 使用方法：for (property in expression) statement;(每次执行时都会将expression中存在的一个属性名赋值给变量propName，直到对象中所有属性都被枚举一遍为止)
  - 注意：
    - var 不是必须的，但是为保证局部变量，推荐使用var
    - ECMAScript对象的属性没有顺序，通过for-in循环输出的属性名的顺序是不可预测的，所有的属性都会被返回一次，但是返回的先后次序可能会因浏览器而异；
    - 表示要迭代的对象的变量值为null或undefined，for-in语句会抛出错误，ECMAScript5更正了这一行为，不再抛出错误，只是不执行循环体，为了保证最大限度的兼容性，建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined
- label语句
  - 作用：可以在代码中添加标签，以便将来使用
  - 使用方法：label：statement
  - 示例：
    - start标签：可以在将来由break或continue语句引用。加标签的语句一般都要与for语句等循环语句配合使用
      ```
      start：for(var i = 0; i< count; i++) {
        alert(i);
      }
      ```
- break和continue语句
  - 作用：用于在循环中精确的控制代码的执行
    - break：立即退出循环，强制继续执行循环后面的语句
    - continue：立即退出循环，退出循环后会从`循环的顶部`继续执行
    - 联用break、continue、label语句能够执行复杂的操作，但如果使用过度，也会给调试带来麻烦，因此使用label语句一定要使用描述性的标签，同时不要嵌套过多的循环。
- with语句
  - 作用：将代码的作用域设置到一个特定的对象中
  - 目的：为简化多次编写同一个对象的工作
  - 语法：with(expression) statement;
  - 缺点：
    - 大量使用with语句会导致性能下降，给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句
    - 严格模式下不允许使用with语句，否则将视为语法错误
  - 以下代码是相等的：
    ```js
      var qs = location.search.substring(1);
      var hostName = location.hostname;
      var url = location.href;
    ```
    使用with语句关联了location对象，这意味着在with语句的代码块内部，每个变量首先被认为是一个局部变量，如果局部环境中找不到该变量的定义，则查询location对象中是否有同名属性，发现则以location对象属性的值作为变量的值
    ```js
      with(location) {
        var qs = search.substring(1);
        var hostName = hostname;
        var url = href;
      }
    ```
- switch 语句
  - 为解决多个 if else 的问题
  - 代码段
    - 需要混合几种情形的时候不要忘了在代码中添加注释，说明有意省略了 break 关键字
    - switch 语句自己的特色：
      - 可以在 switch 语句中使用任何数据类型（在很多其他语言中只能使用数值），无论字符串、对象和其他
      - 每个 case 的值不一定是常量，可以是变量，或者表达式
      - 每个 case 都可以返回一个布尔值
      - switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换
  ```js
    switch (expression) {
      case value:
      <!-- 合并两种情形 -->
      case value: statement break;
      case value: statement break;
      default: statement
    }
  ```

## 函数
- 基本介绍
  - 通过函数可以封装任意多条语句，可以在任何地方、任何时候调用执行
  - ECMAScript中的函数使用function关键字来声明，后跟一组参数及函数体
  - 基本语法：
    - 调用：通过 函数名 functionName(arg0, arg1)
    - 返回值：
      - 在函数定义时不必指定是否返回值
      - 位于 return 语句之后的任何代码都永远不会执行
      - return 语句可以不带有任何返回值，这种情况下，函数在停止执行后将返回undefined值，这种用法一般用在需要提前停止函数执行而又不需要返回值的情况下
      - 推荐做法：函数始终都返回一个值，或者永远都不返回值
  - 严格模式下对函数的限制（发生则导致语法错误，代码无法执行）
    - 不能把函数名、参数名命名为eval或arguments
    - 不能出现两个命名参数同名的情况
    ```js
    function functionName(arg0,arg1,...,argN) {
      statements
    }
    ```
- 理解参数
  1.函数不介意传递进来的参数个数和参数类型
  2.定义函数接收的参数个数并不一定要和调用函数传递的参数相等
    2.1 ECMAScript中的参数在内部是用一个数组来表示的，函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）
  ```js
    function functionName_2() {
      arguments[0];
    }

    functionName_1();
    functionName(1,2,3);
  ```
 - 定义的函数：functionName_2 和调用函数 functionName_1
  - 调用函数时传递的参数将会以数组的形式传递给定义的函数functionName_2(as 2),如果2有参数（参数的个数和传入的形参个数可以不对等），两者可以混用；
  - 调用函数时以数组的形式传入的参数将会被定义的函数2以arguments对象去获取到每一个参数，arguments是一个类数组，与数组类似，因此也可以用方括号的形式arguments[0]去访问每一个元素，也有length属性可以去确定传递进来的参数的个数
  - 定义的函数 functionName_1(as 1)可以不带参数，参数由2给出，可以用arguments去获取，因此，1的实参不是必须的，写出来只是为了提供便利
  - 重写函数的方式可以作为重载，虽然不那么完美，但是也可以弥补ECMAScript的遗憾
  - arguments可与命名参数一起使用，同时也是保持同步的，但是要注意的是，它们并不是内存空间相同，相反，内存空间是独立的，但是值可以同步
  - 如果传入的参数和定义的函数的参数不对等时，比如传入的参数只有一个，而定义的参数大于传入的参数，则定义的参数是被默认为undefined，和定义了变量但是又没有初始化一样
  - 严格模式对如何使用arguments对象作出了一些限制，实参大于传入的形参时，没有被传入参数的将会被默认为undefined，如果重写arguments的值，比如只传入了一个参数1，定义这边的参数有两个，在这里，arguments[1]就不能重写，否则会导致语法错误，代码不会被执行
  - ECMAScript中所有的参数传递的都是值，不可能通过引用传递参数

- 没有重载
  - ECMAScript函数不能像传统意义上那样实现重载，传统意义的重载是为一个函数编写两个定义，只要这两个定义的签名不同即可，而ECMAScript函数没有签名，因为其参数是由包含0或多个值的数组来表示的，没有函数签名，真正的重载是不可能做到的。
  - ECMAScript通过检查传入函数中参数的类型和数量并作出不同的反应，就可以模仿方法的重载。

## 小结
- 基本数据类型：Undefined、Null、Boolean、Number、String
- 没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有的数值
- 复杂类型Object是这门语言中所有对象的基础类型
- 严格模式为这门语言中容易出错的地方施加了限制
- ECMAScript 提供了很多与C及其他类C语言中相同的基本操作符，包括算术操作符，布尔操作符，关系操作符，相等操作符及赋值操作符等
- 借鉴了很多流控制语句，如if、for、switch等
- 函数与其他语言中函数的不同之处：
  - 无需指定函数的返回值：可以在任何时候返回任何值
  - 未指定返回值的函数返回的是一个特殊的undefined值
  - 没有函数签名的概念，函数参数是以一个包含0或多个值得数组的形式传递的
  - 可以向函数传递任意数量的参数，并且通过arguments对象来访问这些参数
  - 不存在函数签名的特性，所以ECMAScript函数不能重载

# 变量、作用域和内存问题

- 基本类型、引用类型的值；执行环境；垃圾收集
- JavaScript变量是松散类型，决定了它只是在特定时间用于保存特定值的一个名字，不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变

## 基本类型和引用类型的值

|类型|指的是什么|如何访问|
|----|--------|--------|
|基本类型值|简单的数据段|按值访问，可操作保存在变量中的实际的值|
|引用类型值|由多个值构成,保存在内存中的对象|JavaScript不允许直接访问内存中的位置，不能直接操作对象的内存空间，在操作对象时实际上是在操作对象的引用而不是实际对象，为此，引用类型的值是按引用访问的（复制保存着对象的某个变量时，操作的是对象的引用，为对象添加属性时，操作的是实际的对象）|

- 动态的属性
  
  类型|定义方式|操作|说明了什么
  |----|----|-----|-----------|
  |基本类型|创建一个变量并为该变量赋值|不能给基本类型添加属性（添加也不会导致错误，但是下一行访问这个属性该属性会不存在）|基本类型不能动态添加属性|
  |引用类型|创建一个变量并为该变量赋值|可为其添加属性和方法，也可以删除和改变其属性和方法|只能给引用类型值动态的添加属性以便将来使用|
- 复制变量值
  
  |类型|操作|结果|是否独立|
  |----|-----|--|-------|
  |基本类型|从一个变量向另一个变量复制基本类型的值|在变量上创建一个心智，把该值复制到为新变量分配的位置上|独立的两个个体，可参与任何操作且不受影响|
  |引用类型|从一个变量向另一个变量复制引用类型的值|将存储在变量对象中的值复制一份放到为新变量分配的空间中，这个值的副本是一个指针，指向存储在堆中的一个对象|改变其中一个变量会影响另一个变量|
- 传递参数（函数参数可理解为局部变量）
  - ECMAScript中所有函数的参数都是按值传递的

  |类型|值传递|操作|结果|重写参数|
  |----|-----|----|----|------|
  |基本类型|如同基本类型变量的复制|被传递的值会被复制给一个局部变量|局部变量的变化不会反应在函数的外部|原来的依旧局部，依旧独立|
  |引用类型|如同引用类型变量的复制|把被传递的值在内存中的地址复制给一个局部变量|局部变量的变化会反应在函数的外部|如果在函数内部将传递的对象重写，这个变量的引用就是一个局部对象，在函数执行完毕以后立即销毁|
- 检测类型
  - typeof，instanceof
  - instanceof的语法：result = variable instanceof constructor
    - 原理：根据原型链来识别引用类型，结果是instanceof会返回true
    - 规定：所有引用类型的值都是Object的实例，在检测引用类型值和object构造函数时始终返回true，若用于检测基本类型的值，会返回false，因为基本类型不是对象
  
  |类型|基本类型|引用类型|特殊类型（Null）|正则表达式|
  |----|------|----------|-------------|---------|
  |typeof|String、Number、Boolean、undefined|Object|Object|function|
  |instanceof|false|true||

## 执行环境及作用域

-简介
  - 执行环境
    - 执行环境定义了变量或函数有权访问的其他数据，决定它们各自的行为。
    - 每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中，编写的代码无法访问这个对象，但是解析器在处理数据时会在后台使用它
    - 执行环境会根据ECMAScript所在的宿主环境不同，表示执行环境的对象也不一样。
      - web中，全局执行环境（最外围的一个执行环境）是window对象，所有的全局变量和函数都是作为window对象的属性和方法创建的
      - 执行环境中代码执行完毕后，环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局环境直到应用程序退出--关闭网页或浏览器--时才会被销毁）
    - 每个函数都有执行环境，执行流进入一个函数，函数的环境就会被推入一个环境栈中，函数执行完毕后，栈将其环境弹出，把控制权返回给之前的执行环境
  - 作用域链
    - 代码在一个环境中执行，会创建变量对象的一个作用域链，其用途是保证对执行环境有权访问的所有变量和函数的有序访问，作用域链的前端，始终都是当前执行的代码所在环境的变量对象，若这个环境是函数，则将其活动对象（在最开始时只包含一个变量）作为变量对象
    - 全局执行环境的变量对象始终都是作用域链中的最后一个对象
    - 标识符解析：沿着作用域链一级一级的搜索标识符的过程，从作用域链的前端开始，逐级的向后回溯，直至找到标识符为止，否则就会发生错误
    - 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数，这些环境之间的联系是线性、有次序的。
    - 函数的参数也被当做变量来对待，因此其访问规则与执行环境中的其他变量相同。
- 延长作用域链
  - 操作：在作用域链的前端添加一个变量对象
  - 方法：
    - try-catch语句的catch块：创建一个新的变量对象，其中包含的是被抛出的错误对象的声明
    - with语句：将指定的对象添加到作用域链中
- 没有块级作用域
  - 声明变量：var 声明的变量会自动添加到最接近的环境中（with中，最接近的环境是函数环境；初始化变量时没有使用var声明会自动被添加到全局环境）
  - 查询标识符：搜索过程从作用域链的前端开始，向上主机查询与给定的名字匹配的标识符，直到找到该标识符，搜索过程停止，变量就绪；如果没有找到，则意味着该变量尚未声明。
    - 若存在局部定义，搜索自动停止，不再进入另一个变量对象。
    - 变量查询有一定代价，访问局部变量要比访问全局变量更快，因为不用向上搜索作用域链，JavaScript引擎在优化标识符查询方面做得不错，在将来这个差别可以忽略不计。

## 垃圾收集

-简介
  - JavaScript具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存
  - 原理：找出那些不再继续使用的变量，然后释放其占用的内存。因此，垃圾收集器会按照固定的事件间隔（或代码执行中预定的收集时间），周期性的执行这一操作。
  - 策略：标记清除（常用）、引用计数（不太常用）
- 标记清除
  - 在运行时给存储在内存中的所有变量都加上标记，然后去掉环境中的变量以及被环境中的变量引用的变量的标记,在此之后再被加上标记的变量将被视为准备删除的变量，因为环境中的变量已经无法访问到这些变量了，最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
- 引用计数
  - 含义：跟踪记录每个值被引用的次数
  - 声明一个变量并将一个引用类型值赋给该变量时，这个值得引用次数+1，若该值再次被引用，则继续+1，若包含这个值的变量又取得了另外一个值，则这个值的引用次数-1，当这个值的引用次数=0，即无法访问这个值，因此就收回其占用的内存空间，当垃圾收集器下次再运行时，就会释放那些引用次数为0的值所占用的内存。
    - 问题：循环引用：循环引用一个值会导致其被引用次数永远都不会为0，为避免类似这样的循环引用问题，最好是在不使用它们时手动断开原生JavaScript对象与DOM元素之间的连接。
    - IE9把BOM、DOM都转换成了真正的JavaScript对象，如此就避免了两种垃圾收集算法并存导致的问题，也消除了常见内存泄漏的现象
- 性能问题
  - IE原来的垃圾收集器是根据内存分配量运行的，达到某个临界值垃圾收集器就会运行。而若这个临界值多次被触发，垃圾收集器就会频繁的运行，导致严重性能问题
  - IE7调整了这个垃圾收集例程，将临界值调整为动态修正；
    - 初始临界值与IE6相等，如果`垃圾收集例程回收的内存分配量低于15%`(要干嘛？)，则变量、字面量、数组元素的临界值就会加倍。如果例程回收了85%的内存分配量，则将各种临界值重置回默认值，这一调整，极大的提升了IE在运行包含大量JavaScript的页面时的性能。
- 管理内存
  - 解除引用：确保占用最少的内存可以让页面获得更好的性能，优化内存占用的最佳方式是为执行中的代码只保存必要的数据。一旦数据不再有用，则通过将其设置为null来释放其引用
    - 解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。

## 小结
- JavaScript变量可以用来保存两种类型的值：基本类型值（其值源自5种基本数据类型：Undefined、Null、Boolean、Number、String）、引用类型值
- 特点：
  - 基本类型值：在内存中占据固定大小的空间，因此被保存在栈内存中
  - 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本
  - 引用类型的值是对象，保存在堆内存中
  - 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针
  - 从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象
  - typeof：确定一个值是哪种基本类型；instanceof：确定一个值是哪种引用类型
- 执行环境：
  - 执行环境：全局执行环境、函数执行环境
  - 每进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链
  - 局部环境能访问函数作用域->其包含福环境->全局环境
  - 全局环境只能访问定义在全局环境中的变量和函数，而不能直接访问局部环境中的任何数据
  - 变量的执行环境有助于确定应该何时释放内存
- 垃圾收集例程：
  - 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除
  - 标记清除：给当前不使用的值加上标记，然后再回收其内存
  - 引用计数：跟踪记录所有值被引用的次数（JavaScript引擎目前都不再使用这种算法，IE中访问非原生JavaScript对象`DOM元素`时，这种算法仍然可能会导致问题）
    - 当代码中存在循环引用现象时，引用计数算法会导致问题
  - 解除变量的引用不仅有助于消除循环引用现象，对垃圾收集也有好处，为了确保有效的回收内存，应该及时解除不再使用的全局对象、全局对象属性、循环引用变量的引用。



# 引用类型

- 引用类型的值（对象）是引用类型（一种数据结构，有时也被称为`对象定义`）的一个实例
- 对象时某个特定引用类型的实例，新对象 = new `构造函数（出于创建新对象的目的而定义的一个函数）`

## Object 类型

- 创建方式：
  - 新对象 = new Object()
  - 对象字面量表示法(使用场景：在只考虑对象属性名的可读性时使用，也是向函数传递大量可选参数的首选方式；通过此方法定义对象不会调用Object构造函数)：var 新对象 = {};最后一个属性不需要逗号“,”、留空其花括号可以定义只包含默认属性的方法和对象（应该是自带的属性比如类似于object.defineproperty的writeable这种类型的）
- 访问方式：
  - 点表示法：除了必须使用变量来访问属性，否则其他皆使用点表示法
  - 方括号表示法：优点：可以通过变量来访问属性（若属性名中包含会导致语法错误的字符，或属性名使用的是关键字或保留字，也可以使用方括号表示法：“first name”包含一个空格，不能使用点表示法访问，属性名中却可以包含非字母非数字的）
- Object在应用程序中存储和传输数据是非常理想的选择

## Array 类型

- 与其他语言的异同点：
  - 共同点： 都是有序列表
  - 区别：
    - 数组的每一项可以保存任何类型的数据
    - 数组的大小是可以动态调整的（随着数组的添加自动增长以容纳新增数据）
- 创建方式：
  - 使用Array构造函数： var arr = [,new](可省略，效果相同) Array([,length]); length 可要可不要，如果预先知道要保存的项目数量，可传入该数量，也可以传递数组要包含的项
  - 数组字面量表示法：var arr = [];多个数组项之间以逗号隔开；推荐写法：arr = []/ ["red","blue"];使用时不会调用Array构造函数
- 访问方式：
  - 在方括号中添加索引:[index]
  - 数组的length不是只读的，通过设置该属性可以从数组的末尾移除项或向数组中添加新项（新项取值为undefined，数组的长度是有限制的）

### 检测数组

- 方式：
  - <strong>instanceof</strong>：if (value instanceof Array)：缺点：假定只有一个全局执行环境，当网页中包含多个框架，则存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。从一个框架向另一个框架传入一个数组，传入的数组与第二个框架中原生创建的数组分别具有各自不同的构造函数
  - <strong>Array.isArray()</strong>:ECMAScript 5 提出，目的：最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。

### 转换方法

- 所有对象都具有：toLocaleString( ),toString( ),valueOf( ),默认情况下返回以逗号分隔的字符串形式返回数组项
  - alert( ): 要接收字符串参数，会在后台调用toString()方法，会得到与直接调用toString()方法相同的结果
  - toString( ):返回由数组中的每个值的字符串形式拼接而成的一个以逗号分隔的字符串
  - valueOf( ):返回数组
  - toLocaleString( ): 经常会返回与toString( )和valueOf( )方法相同的值。但是不同的是：比如调用数组的该方法，它为了取得每一项的值，调用的是每一项的toLocaleString( )方法，而不是toString()
- join( ): 接受参数：用作分隔符的字符串，也可以不传递任何值或者undefined，此时则使用默认分隔符“逗号”
- ps:如果数组中的某一项的值是null、undefined，则该值在join(),toLocaleString(),toString(),valueOf()方法返回的结果中以空字符串表示

### 栈方法

- 栈：LIFO(后进先出)，只发生在栈的顶部
- 方法：
  - push():return 修改后的数组长度 = push(接收任意数量参数)-> 逐个添加到数组末尾
  - pop(): return 移除的项 = pop():移除数组末尾的最后一项，减少length的值

### 队列方法

- 队列：FIFO(先进先出)，从列表的末端添加项，从列表的前端移除项
- 方法：
  - shift(): 移除数组中的第一个项并返回该项，数组长度 - 1
  - push(): return 修改后的数组长度 = push(接收任意数量参数)-> 逐个添加到数组末尾
- 从相反方向模拟队列，在数组前端添加项，从数组末尾移除项
- 方法：
  - unshift(): 与shift用途相反，return newLength = unshift(在数组前端添加任意个项),IE 7 - 返回的是undefined，IE8(非兼容模式)返回正确的长度值
  - pop(): return 移除的项 = pop():移除数组末尾的最后一项，减少length的值

### 重排序方法

- 重排序方法：
  - reverse():反转数组项的顺序
  - sort()：按升序排列数组项，即最小的值位于最前面，最大的值排在最后面，比较的是`字符串`
    - 会调用每个数组项的toString()转型方法，然后比较得到的字符串，会导致：10 < 5的情况，因为比较的字符串会根据1 < 5将10看做小于5.
    - sort()可以接收一个比较函数作为参数，以便指定哪个值位于哪个值前面：sort(compare)
    - compare:
    ```js
    function compare(value1,value2) { // 前者为降序，后者为升序
      if (value1 < value2) {
        return 1; //-1
      } else if (value1 > value2) {
        return -1; // 1
      } else {
        return 0;
      }
    }
    ```
    - 但是如果是只想排序了后反转顺序，reverse方法会更快一点
    - 对于数值类型或其valueOf() 方法会返回数值类型的对象类型，可以使用一个更简单的比较函数：compare比较函数通过返回一个 < 0 或者 > 0 或 = 0的值来影响排序结果
    ```js
      function compare(value1,value2) {
        return value2 - value1;
      }
    ```

### 操作方法

- concat(): 基于当前数组中的所有项创建一个新数组
  - 操作：
    - 不传参数： 返回新的 `co`的副本为`co2`，和`co`一样，操作互不影响
    - 传参数（操作的是副本，原来的数组不被改变）：
      - 普通数组：被添加到结果数组中
      - 不是数组['yellow', ['black','brown']]：值被简单的添加到结果数组的末尾
    ```js
    var co = ['red','blue','yellow'];
    var co2 = co.concat([,可传值也可不传值]);
    ```
- slice(): 基于当前数组中的一或多个项创建一个新数组，不会影响原始数组，返回的是副本。
  - 操作： 可接受 1~2个参数
    - 1个参数：return 从指定位置到数组末尾的所有项
    - 2个参数：return 起始位置和结束位置之间的项，不包括结束位置的项
  - 参数为负数时：用数组的长度加上该负数来确定相应的位置，如果结束位置小于起始位置则返回空数组。
- splice():向数组的中部插入项
  - 操作：
    - 接收参数:(要删除的第一项, 要删除的项数,要插入的项)
      - 2个参数 --> 删除：要删除的第一项的位置和项数
      - 3个参数 --> 插入/替换：
        - 插入：(起始位置, 删除 0 项, 插入的项:可以是多个字符串或者其他)
        - 替换：(指定位置, 删除任意数量项,插入任意数量项)
    - return arr[从原始数组中删除的项（如果没有被删除则返回空数组）]

### 位置方法

- indexOf()、lastIndexOf()
  - 接收两个参数：(要查找的项，查找的七点位置索引)
  - 返回要查找的项在数组中的位置
  - 没有找到的情况下返回 -1
  - 比较第一个参数与数组中的每一项会使用“===”全等操作符，即要求查找的项严格相等
  - 区别：
    - indexOf(): 从数组的开头向后查找
    - lastIndexOf():从数组的末尾开始向前查找

### 迭代方法

- 共同点：
  - 接收两个参数：(要在每一项上运行的函数，（可选的）运行该函数的作用域对象（影响this的值）)
  - 传入这些方法中的函数（第一个参数）接收三个参数：(数组项的值，该项在数组中的位置，数组本身)
- 不同的方法：
  - every():对数组中的每一项运行给定函数，每一项返回true，则返回true，用于查询数组是否满足某个条件
  - some():对数组中的每一项运行给定函数，任一项返回true，则返回true，用于查询数组是否满足某个条件
  - forEach():对数组中的每一项运行给定函数，无返回值
  - map():对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组
  - filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组

### 归并方法

- reduce(),reduceRight()
- 共同点：
  - 接收两个参数：在每一项上调用的函数func，可选的作为归并基础的初始值
  - 传进归并方法的函数func()接收四个参数：前一个值，当前值，项的索引，数组对象
- 不同点：
  - reduce: 从数组的第一项开始，逐个遍历到最后
  - reduceRight: 从数组的最后一项开始，向前遍历到第一项

## Date 类型

- 创建日期对象
  - var now = new Date()
  - 无参数：now = 自动获得当前日期和时间
    - ECMAScript 5添加了Data.now()方法，返回的是调用这个函数时的日期和时间的毫秒数，作用：简化使用Data对象分析代码的工作
  - 有参数：接收从UTC时间1970年1月1日午夜起到指定日期经过的`毫秒数`（过于复杂）
    - 简化有参数的情况(两个方法)：
      - Date.parse(): 接收一个表示日期的字符串参数，尝试根据这个字符串返回相应的日期的毫秒数
        - 支持的日期格式并没有规定（将地区设置为美国的浏览器通常接受以下日期格式）：
          - 月/日/年
          - 英文月名 日，年
          - 英文星期几 英文月名 日 年 时：分：秒 时区
          - ISO 8601 扩展格式： YYYY-MM-DDTHH:mm:ss.sssZ(如2004-02-25T00:00:00,前提是要兼容ECMAScript5)
        - 如果传入的参数不能表示日期，会返回NaN
        - 直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()
          - new Date("05/23/2019") == new Date(Date.parse("05/23/2019"))
      - Date.UTC():
        - 参数： 年份`(必须)`、基于0的月份`(必须)`（从0开始计数，0是一月，1是二月...）、月中的哪一天（1-31）、小时数（0-23）、分钟、秒、毫秒数

### 继承的方法

- toLocaleString(): 按照浏览器设置的地区相适应的格式返回日期和时间，时间格式中会包含AM、PM，不会包含时区信息
- toString()：返回带有时区信息的日期和时间，一般以军用时间(0-23)表示
- valueOf()：返回日期的毫秒表示，可以用比较操作符来比较日期值

### 日期格式化方法

- toDateString(): 以特定于实现的格式显示星期几、月、日、年
- toTimeString(): 以特定于实现的格式显示时、分、秒、时区
- toLacaleDateString(): 以特定于实现的格式显示星期几、月、日、年
- toLocaleTimeString(): 以特定于实现的格式显示时、分、秒
- toUTCString()、toGMTString()(向后兼容，与toUTCString()等价，一般不建议使用): 以特定于实现的格式完整的UTC日期

### 日期/时间组件方法

方法|说明
----|----
getTime() | 返回表示日期的毫秒数；与valueOf()方法返回的值相同
setTime(毫秒)| 以毫秒数设置日期，会改变整个日期
getFullYear()| 取得4位数的年份（如2007而非仅07）
getUTCFullYear()| 返回UTC日期的4位数年份
setFullYear(年) |设置日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
setUTCFullYear(年)| 设置UTC日期的年份。传入的年份值必须是4位数字（如2007而非仅07）
getMonth()| 返回日期中的月份，其中0表示一月，11表示十二月
getUTCMonth() |返回UTC日期中的月份，其中0表示一月，11表示十二月
setMonth(月) |设置日期的月份。传入的月份值必须大于0，超过11则增加年份
setUTCMonth(月) |设置UTC日期的月份。传入的月份值必须大于0，超过11则增加年份
getDate()| 返回日期月份中的天数（1到31）
getUTCDate()| 返回UTC日期月份中的天数（1到31）
setDate(日)| 设置日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
setUTCDate(日) |设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数，则增加月份
getDay()| 返回日期中星期的星期几（其中0表示星期日，6表示星期六）
getUTCDay() |返回UTC日期中星期的星期几（其中0表示星期日，6表示星期六）
getHours() |返回日期中的小时数（0到23）
getUTCHours() |返回UTC日期中的小时数（0到23）
setHours(时) |设置日期中的小时数。传入的值超过了23则增加月份中的天数
setUTCHours(时)| 设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数
getMinutes()| 返回日期中的分钟数（0到59）
getUTCMinutes() |返回UTC日期中的分钟数（0到59）
setMinutes(分) |设置日期中的分钟数。传入的值超过59则增加小时数
setUTCMinutes(分) |设置UTC日期中的分钟数。传入的值超过59则增加小时数
getSeconds() |返回日期中的秒数（0到59）
getUTCSeconds() |返回UTC日期中的秒数（0到59）
setSeconds(秒) |设置日期中的秒数。传入的值超过了59会增加分钟数
setUTCSeconds(秒) |设置UTC日期中的秒数。传入的值超过了59会增加分钟数
getMilliseconds() |返回日期中的毫秒数
getUTCMilliseconds() |返回UTC日期中的毫秒数
setMilliseconds(毫秒)| 设置日期中的毫秒数

## RegExp 类型

- 创建正则表达式
  - 字面量形式
    - var expression = /pattern/flags
      - pattern(模式): 可以为任何简单、复杂的正则表达式（可包含字符串、限定符、分组、向前查找、反向引用）
      - flags(标志：每个正则表达式都可带有一或多个标志，用于表明正则表达式的行为)
        - 匹配模式支持的3个标志：
          - g:全局模式，即模式被应用于所有的字符串，而非在发现第一个匹配项时立即停止
          - i:表示不区分大小写模式，即在确定匹配项时忽略模式与字符串的大小写
          - m:表示多行模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项
        - 模式中使用的所有`元字符`都必须转义：([{\^$|)?*+.]}
      - 始终共享一个RegExp实例
  - RegExp 构造函数
    - 接收参数：(要匹配的字符串模式,可选的标志字符串)
    - 不能把正则表达式字面量传递给RegExp构造函数
    - 由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义，所有元字符都必须双重转义,已经转义过的字符串也要转义
    - 使用构造函数创建的每一个新RegExp实例都是一个新实例

### RegExp 实例属性

  1.global：boolean，表示是否设置了 g 标志（是否全局查找，而不是只找到一个就停止）
  2.ignoreCase: boolean,表示是否设置了 i 标志（忽略大小写）
  3.lastIndex：整数，表示开始搜索以一个匹配项的字符位置，从0算起
  4.multiline：布尔值，表示是否设置了m标志
  5.source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。source属性保存的是规范形式的字符串，即字面量形式所用的字符串。

### RegExp 实例方法

- exec(): 专门为捕获组而设计的
  - 接受一个参数：return (包含第一个匹配项信息的数组 / null)= exec(应用模式的字符串)
  - return 的数组包含： [与整个模式匹配的字符串，(,与模式中的捕获组匹配的字符串...)]
  - 在模式中设置全局项和不设置全局项的区别
    - 设置全局标志：每次返回一个匹配项，会在字符串中继续查找新匹配项的信息，lastIndex的值在每次调用exec后都会增加
    - 不设置全局标志：在同一个字符串上多次调用exec()将多次返回第一个匹配项信息，lastIndex在非全局模式下始终不变
- test():用于指导目标字符串与某个模式是否匹配，不需要知道其文本内容，用于判断
  - 接收参数：字符串
  - 返回：匹配->true;不匹配->false
- 继承的方法：
  - toLocaleString()、toString(): 返回正则表达式的字面量，与创建正则表达式的方式无关
  - valueOf(): 返回正则表达式的本身

### RegExp构造函数属性

长属性名|短属性名|说明
-------|--------|----
input|$_|最近一次要匹配的字符串
lastMatch|$&|最近一次的匹配项
lastParen|$+|最近一次匹配的捕获组
leftContext|$`|input字符串中lastMatch之前的文本
multiline|$*|布尔值，表示是否所有表达式都使用多行模式
rightContext|$'|Input字符串中lastMatch之后的文本

RegExp.$1...RegExp.$9分别用于存储第一、第二...第九个匹配的捕获组

### 模式的局限性

- 不支持的特性
  - 匹配字符串开始和结尾的\A和\Z锚
  - 向后查找
  - 并集、交集类
  - 原子组
  - Unicode支持
  - 命令的捕获组
  - s(single,单行) 和 x(free-spacing,无间隔)匹配模式
  - 条件匹配
  - 正则表达式注释

## Function 类型

- 函数：
  - 都是Function类型的实例，与其他引用类型一样具有属性和方法
  - 实际上是一个指向函数对象的指针，不会与某个函数绑定
  - 使用不带圆括号的函数名是访问函数指针，而非调用函数
- 声明函数的三种方式：
  - 函数表达式：var sum = function(){};(末尾有分号)
  - 函数声明：function sum(){}：与函数表达式的唯一区别是：使用该方法声明函数，该函数会有变量提升，提升到作用域的最顶层。
  - 使用Function构造函数：Function构造函数可以接收任意数量的参数，最后一个参数始终都被看成是函数体，而前面的参数则枚举了新函数的参数
    - var sum = new Function("num1","num2","return num1 + num2"); // 不推荐
    - 缺点：导致两次解析代码（1.解析常规ECMAScript代码；2.解析传入构造函数中的字符串）
    - 优点：对理解函数是对象，函数名是指针的概念很直观。

### 没有重载

- 可以使用函数的参数的特点去模仿重载
  - arguments的传入，而不管形参
  
### 函数声明与函数表达式

- 解析器在想执行环境中加载数据时，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可访问）
- 函数表达式则必须等到解析器执行到它所在的代码行才会真正被解释执行

### 作为值的函数

- 函数可用作为值来使用
- 要访问函数的指针而不执行函数的话，必须去掉函数名后面的那对圆括号
- 在默认情况下，sort()会调用每个对象的toString()方法以确定它们的次序

### 函数内部属性

- 函数内部特殊对象：
  - arguments:
    - 类数组对象，包含着传入函数中的所有参数，主要用途是保存函数参数
    - 有一个名叫callee的属性，是一个指针，`指向拥有这个arguments对象的函数`，可用于消除递归算法导致的紧密耦合现象：arguments.callee
    - ps: 定义arguments.caller属性，严格模式下会导致错误，非严格模式下始终是undefined（为分清arguments.caller和函数的caller属性）
    - 严格模式下：
      - arguments.callee(严格模式下会导致错误)
      - arguments.caller属性，严格模式下会导致错误
      - 不能为函数的caller属性赋值，否则会导致错误
    - 以上是为了加强这门语言的安全性，如此第三方代码就不能再相同环境里窥视其他代码了
  - this:this引用的是`函数据已执行的环境对象`，也可以说是this的值（this指向调用函数的作用域）
- 函数的名字是一个包含指针的变量，即使是在不同的环境中执行，不同环境调用的函数仍然是同一个
- 函数对象属性：
  - caller：
    - 保存着调用当前函数的函数的引用：在全局作用域中调用当前函数，其值为null
    - 可用于实现更松散的耦合：arguments.callee.caller来访问相同的信息

### 函数的属性和方法
- 属性：
  - length：表示函数希望接收的命名参数的个数
  - prototype：保存它们所有实例方法的真正所在，ECMAScript5中，不可枚举，因为使用for-in无法发现
- 方法：
  - 非继承：
    - apply: (在其中运行函数的作用域this值，参数数组[Array的实例/arguments对象])
    - call: (在其中运行函数的作用域this值，参数1，参数2，参数n...)
    - bind():ECMAScript5,会创建一个函数的实例，其this值会被绑定到传给bind()函数的值
    - 作用：
      - 在特定的作用域中调用函数，即设置函数体内this对象的值
      - 能够扩充函数赖以运行的作用域，其好处是对象不需要与方法有任何耦合关系
  - 继承：只返回函数的代码
    - toLocaleString():
    - toString():
    - valueOf():

## 基本包装类型

- 每当读取一个基本类型值，后台会创建一个对应的基本包装类型的对象，从而我们能够调用一些方法来操作这些数据
  - 基本类型值不是对象，逻辑上不应该有方法（但是实际上是有方法的），为了实现这种直观的操作，后台已经自动完成了一系列的处理：
    - 创建String类型的一个实例：var s1 = new String('some text');
    - 在实例上调用指定的方法:s1.substring(2);
    - 销毁这个实例:s1 = null;
- 引用类型与基本包装类型的主要区别就是`对象的生存期`，使用new 操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能再运行时为基本类性质添加属性和方法。
- 可以显式的调用Boolean、Number、String来创建基本包装类型的对象（不建议）
  - 基本包装类型的实例调用typeof会返回object，且所有基本包装类型的对象都会被转换为布尔值true
  - 使用 new 调用基本包装类型的构造函数（typeof => object），与直接调用同名的转型函数（typeof=>转型函数的基本类型）是不一样的

### Boolean类型

- Boolean类型是布尔值对应的引用类型
- 创建Boolean对象的创建方式：var booleanObject = new Boolean(true)
- Boolean重写的方法：
  - valueOf() => 返回基本类型值：true/false
  - toString() => 返回字符串true/false
- 基本类型与引用类型的布尔值的区别：
  - typeof: 基本类型：boolean;引用类型：object
  - instanceof:基本类型：false；Boolean对象：true
- 误解点：
  ```js
    var falseObject = new Boolean(false);
    var result = falseObject && true; // falseObject:不是对它的值进行求值，而是对这个对象求值：`布尔表达式中的所有对象都会被转换为true`
    alert(result) // true

    var falseValue = false;
    result = falseValue && true;
    alert(result); // false
  ```

### Number类型

- Number是数字类型对应的引用类型；
  - 创建方式：var numberObject = new Number(10);
- 继承且重写的方法：(这三个方法都可以通过向上或向下舍入，做到以最准确的形式来表示带有正确小数位的值)
  - valueOf():返回对象表示的基本类型的数值
  - toLocaleString()、toString([,表示基数的参数]):返回字符串形式的数值
- 用于将数值格式化为字符串的方法：
  - toFixed(num[表示显示几位小数]): 按照指定的小数位返回数值的字符串表示
    - 有自动舍入的特性，适合处理货币值
  - toExponential(num[表示显示几位小数]):返回以指数表示法（e）表示的数值的字符串形式
  - toPrecision():用于得到表示某个数值最合适的格式。会根据要处理的数值决定到底是调用toFixed()还是调用toExponential()
- 使用typeof和instanceof操作符测试基本类型数值与引用类型数值时得到的结果完全不同

### String类型

- String 类型时字符串的对象包装类型
  - 创建方式： var stringObject = new String('str');
- 继承的方法
  - valueOf()、toLocaleString()、toString():返回对象所表示的基本字符串值
- 每个实例都有一个length属性，表示字符串中包含多个字符：字符串中若包含双字节字符，每个字符也仍然算一个字符
- 提供用于辅助完成ECMAScript中字符串的解析和操作的方法：
  - 字符方法：
    - charAt(基于0的字符串位置):以单字符字符串的形式返回给定位置的那个字符
    - charCodeAt(基于0的字符串位置):返回给定位置的字符的字符编码
    - 以方括号加数字来访问字符串中的特定字符：str[index];iE7以后才可以使用，IE7以前返回undefined值
  - 字符串操作方法：
    - concat():
      - var res = strA.concat(str1,str2,str3...strn):用于将一或多个字符串拼接起来，返回拼接得到的新字符串:strA+str1+str2+...+strn
      - 实践中，使用加号操作符(+)更多且比concat()要简便易行
    - slice()、substr()、substring():返回被操作字符串的一个子字符串，接受1~2个参数，第一个参数是`指定字符串的开始位置`，第二个参数`表示字符串到哪里结束`；如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置；不会修改字符串本身的值，只会返回一个基本类型的字符串值，对原始字符串没有任何影响。
      - 区别：
        - slice和substring的第二个参数指定的是字符串最后一个字符后面的位置
        - substr的第二个参数指的是返回的字符个数
      - 传入负值时：
        - slice：将传入的负值与字符串的长度相加
        - substr:将负的第一个参数加上字符串的长度，将负的第二个参数转换为0
        - substring:将所有负值参数都转换为0；会将较小的数作为开始位置，较大的数作为结束位置
  - 字符串的位置方法: 从一个字符串中搜索给定的子字符串，然后返回子字符串的位置，如果没有找到该子字符串，则返回-1；都接收可选的第二个参数，表示从字符串中的那个位置开始搜索
    - indexOf(搜索的字符串，[,搜索的开始位置])：从字符串的开头向后搜索子字符串
    - lastIndexOf(搜索的字符串，[,搜索的开始位置])：从字符串的末尾向前搜索子字符串
  - trim()方法
    - 创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果
    - 其他浏览器还支持非标准的trimLeft()、trimRight()方法，分别用于删除字符串开头和末尾的空格
  - 字符串大小写转换方法（不知道自己的代码将会在哪种语言环境中运行的情况下，还是使用针对地区的方法更为稳妥）
    - toLowerCase():转换为小写
    - toLocaleLoweCase()：转换为小写，针对特定地区的实现（有些地区的语言会为Unicode大小写转换应用特殊的规则，此时就必须使用针对地区的方法来保证实现正确的转换）
    - toUpperCase()：转换为大写
    - toLocaleUpperCase()：转换为大写，针对特定地区的实现（有些地区的语言会为Unicode大小写转换应用特殊的规则，此时就必须使用针对地区的方法来保证实现正确的转换）
  - 字符串的模式匹配方法
    - String类型定义了几个用于在字符串中匹配模式的方法
      - match(): 本质上与调用RegExp的exec()方法相同，只接受一个参数，正则表达式/RegExp对象；返回一个数组：数组的第一项是与整个模式匹配的字符串，之后的每一项（如果有）保存着与正则表达式中的捕获组匹配的字符串
      - search():唯一参数与match()方法的参数相同，由字符串或RegExp对象指定的一个正则表达式；返回字符串中第一个匹配项的索引，如果没有找到匹配项，则返回-1，且是始终从字符串开头向后查找模式
    - replace()：为简化替换子字符串的操作；接受两个参数，(RegExp/str，str/function),如果第一个参数是字符串，那么只会替换第一个子字符串，要想替换所有子字符串，唯一的办法是提供一个适用于全局的正则表达式
      - 当第二个参数为function时，function(模式的匹配项，模式匹配项在字符串中的位置，原始字符串)
    - htmlEscape():转义4个字符（<、>、&&、""）
    - split():基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中；接受的参数：(分隔符[可以是字符串，也可以是一个RegExp对象],可选参数[用于指定数组的大小，以便确保返回的数组不会超过既定大小])
    - localeCompare()方法：
      - 比较两个字符串并返回下列值中的一个；
        - 字符串在字母表中应该排在字符串参数之前，则返回一个负数
        - 如果字符串等于字符串参数，则返回0
        - 如果字符串在字母表中应该排在字符串参数之后，则返回一个正数
    - fromCharCode()方法
      - 接收一或多个字符编码，然后将它们转换成一个字符串，本质上来说与实例方法charCodeAt()执行的是相反的操作
    - HTML方法

      方法|输出结果
      ----|------
      anchor|<a name="name">string</a>
      big()|<big>string</big>
      bold()|<b>string</b>
      fixed()|<tt>string</tt>
      fontcolor(color)|<font color="color">string</font>
      fontsize(size)|<font size="size">string</font>
      italics()|<i>string</i>
      link(url)|<a href="url">string</a>
      small()|<small>string</small>
      strike()|<strike>string</strike>
      sub()|<sub>string</sub>
      sup()|<sup>string</sup>

## 单体内置对象

- 内置对象：由ECMAScript实现提供的，不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在，开发人员不必显式的实例化内置对象，因为已经被实例化了，前面介绍的内置对象有：Object、Array、String
- 单体内置对象：Global、Math

### Global对象

- Global对象在某种意义上时作为一个终极的“兜底儿对象”来定义的，即不属于任何其他对象的属性和方法，最终都是它的属性和方法；没有全局变量或全局函数，所有在全局作用域中定义的属性和函数都是Global对象的属性
- URI编码方法
  - encodeURI()：主要用于整个URI进行编码，不会对本身属于URI的特殊字符进行编码，如“:，\，?，#”
  - encodeURIComponent()：主要用于对URI中的某一段进行编码，会对它发现的任何非标准字符进行编码
  - decodeURI()：与encodeURI相对应，只能对使用encodeURI()替换的字符进行解码
  - decodeURIComponent()：与encodeURIComponent()替换的字符进行解码，即可以解码任何特殊字符的编码
- eval()方法
  - 就像是一个完整的ECMAScript解析器，只接受一个参数（要执行的ECMAScript字符串）
  - 通过eval执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与执行环境相同的作用域链，意味着通过eval执行的代码可以引用在包含环境中定义的变量
  - 在eval中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中，只在eval执行的时候创建
  - 严格模式下，在外部访问不到eval中创建的任何变量或函数
- Global对象的属性

  属性|说明
  ----|----
  undefined|特殊值undefined
  NaN|特殊值NaN
  Infinity|特殊值Infinity
  Error|构造函数Error
  Date |构造函数Date
  RegExp |构造函数RegExp
  Object |构造函数Object
  EvalError |构造函数EvalError
  Array |构造函数Array
  RangeError |构造函数RangeError
  Function |构造函数Function
  ReferenceError |构造函数ReferenceError
  Boolean |构造函数Boolean
  SyntaxError| 构造函数SyntaxError
  String |构造函数String
  TypeError| 构造函数TypeError
  Number |构造函数Number
  URIError |构造函数URIError

  - 禁止给undefined、NaN、Infinity赋值
- window对象
  - Global对象被Web浏览器作为window对象的一部分加以实现的，在全局作用域中申明的所有变量和函数都会成为window对象的属性
  - 取得global对象的方法：
    - this的值等于global对象，而像这样通过简单的返回this来取得global对象，在任何执行环境下都是可行的。无论获取this是通过将函数添加为对象的方法，还是通过调用call(),apply()
    ```js
    var global = function(){
      return this;
    }();
    ```

### Math对象

- Math对象的属性

  属性|说明
  ----|---
  Math.E |自然对数的底数，即常量e的值
  Math.LN10 |10的自然对数
  Math.LN2 |2的自然对数
  Math.LOG2E |以2为底e的对数
  Math.LOG10E |以10为底e的对数
  Math.PI| π的值
  Math.SQRT1_2| 1/2的平方根（即2的平方根的倒数）
  Math.SQRT2| 2的平方根

- min()、max()方法
  - 经常用于避免多余的循环和在if语句中确定一组数的最大值，用于确定一组数值中的最小值、最大值，可接收任意多个数值参数
  - 对普通一串数：
    ```js
    var max/min = Math.max/min(3,4,54,32,15); // max：54，min:3
    ```
  对数组：
    ```js
    var values = [1,2,43,5,6,4,18]
    var max/min =Math.max.apply(Math,values) // 技巧点：把Math设置为apply的第一个参数，从而正确设置this值
    ```

- 舍入方法
  - Math.ceil():执行向上舍入，即它总是将数值向上舍入为最接近的整数
  - Math.floor()：执行向下舍入，即总是将数值向下舍入为最接近的整数
  - Math.round():执行标准舍入，总是将数值四舍五入为最接近的整数

- random()方法
  - 返回0< x <1的随机数

- 其他方法
  
  方法|说明
  ----|----
  Math.abs(num) |返回num 的绝对值
  Math.asin(x) |返回x 的反正弦值
  Math.exp(num) |返回Math.E 的num 次幂
  Math.atan(x) |返回x 的反正切值
  Math.log(num) |返回num 的自然对数
  Math.atan2(y,x) |返回y/x 的反正切值
  Math.pow(num,power) |返回num 的power
  次幂 Math.cos(x) |返回x 的余弦值
  Math.sqrt(num) |返回num 的平方根
  Math.sin(x) |返回x 的正弦值
  Math.acos(x) |返回x 的反余弦值
  Math.tan(x) |返回x 的正切值

## 小结

- 引用类型与传统面向对象程序设计中的类相似，但实现不同
- object是一个基础类型，其他所有类型都从Object继承了基本的行为
- Array类型时一组值的有序列表，提供了操作、转换功能
- Date提供了有关日期和时间的信息，包括当前日期和时间以及相关计算功能
- RegExp类型时ECMAScript支持正则表达式的一个接口，提供正则表达式功能
- 函数是Function类型的实例，函数也是对象，函数也拥有方法用于增强其行为
- 基本包装类型让基本类型值可以被当做对象来访问，三种基本包装类型：Boolean、Number、String
  - 每个包装类型都映射到同名的基本类型
  - 在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作
  - 操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象
- 内置对象：Global、Math

# 面向对象的程序设计



# JavaScript 异步机制

## 同步与异步
1.同步：在函数返回的时候，调用者就能够得到预期结果
1.1 在该情况下：即使调用函数执行任务比较耗时，也会一直等待直到得到预期结果
2.异步：在函数返回时调用者不能得到预期结果，而是需要在将来通过一定的手段得到。
2.1 发出调用之后，马上返回，但是不会马上返回预期结果；调用者不必主动等待，当被调用者得到结果之后，会通过回调函数主动通知调用者

## 单线程、多线程


# <a>标签给链接新开页面的方式
target="_blank"
<a target="_blank" href="">xxx</a>

# Cookie

## 什么是cookie

- web应用程序的出现产生了某个需求：能够直接在客户端上存储用户信息能力；即希望让属于某个特定用户的信息存在这个特定用户自己的机器上，被存储的信息包括但不限于：登录信息、偏好设定、其他数据

- 实现这个需求的第一个方案是以cookie的形式出现的

- cookie：
  - 最初是在客户端用于存储会话信息的
  - 浏览器通过HTTP进行请求，服务器对这个请求发送`Set-Cookie`头作为响应的一部分，其中包含会话信息
    - 服务器响应头可能包含如下：
      - HTTP/1.1 200 OK
      - Content-type: text/html
      - Set-Cookie: name = value
      - Other-header: other-header-value
    - 浏览器存储这样的会话信息，在此之后，给服务器发送信息都会为每个请求添加Cookie HTTP头，发送回服务器的额外信息可以用于唯一验证客户来自于发送的哪个请求
      - 返回服务器的cookie HTTP 头：
        - GET /index.html HTTP/1.1
        - Cookie: name = value
        - Other-header: other-header-value

- 限制：
  - 绑定在特定的域名下的：某个域名创建了它，再发送请求到该域名都会包含这个cookie；确保了储存在cookie中的信息只能让批准的接受者访问，无法被其他域访问
  - cookie被存储在客户端计算机上，加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间。每个域的cookie总数是有限的，浏览器不同，cookie总数不同
    - 删除最近最少使用过的cookie：
      - IE6-：<=20cookie
      - Opera: <=30
    - 随机决定要删除哪个cookie：
      - Firefox
    - IE7+&&Firefox:<=50
    - safari&&chrome:无硬性规定
  - 超过4K就会被丢掉

- cookie的构成：
  - 名称： 唯一确定cookie，不区分大小写，但是最好将其视为区分大小写的，（名称必须是经过URL编码的）
  - 值：储存在cookie中的字符串值，必须经过URL编码
  - 域：cookie对哪个域是有效的，所有向该域发送的请求中都会包含这个cookie信息，这个值可以包含子域，也可以不包含（如果没有明确设定，这个域会被认作来自设置cookie的那个域）
  - 路径：对于制定域中的那个路径，应该向服务器发送cookie
  - 失效时间：表示cookie何时应该被删除的时间戳（即何时应该停止向服务器发送这个cookie），默认情况下，浏览器会话结束时即将所有cookie删除，不过也可以自己设置删除时间（GMT格式的日期），如果设置的失效日期是个以前的时间，则cookie会被立刻删除
  - 安全标志：指定后，cookie只有在使用ssl链接的时候才发送到服务器，

# localStorage

- 存储localStorage时需要对存储的对象进行转换
  - 存储对象：{}时，`localStorage.setItem(key:string,JSON.stringify(value))`
  - 取出对象：`JSON.parse(localStorage.getItem(key))`
